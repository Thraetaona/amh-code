	.file	"binary.cc"
# GNU C++17 (GCC) version 10.2.0 (x86_64-pc-linux-gnu)
#	compiled by GNU C version 10.2.0, GMP version 6.2.1, MPFR version 4.1.0, MPC version 1.2.1, isl version isl-0.21-GMP

# GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
# options passed:  -D_GNU_SOURCE binary.cc -march=znver2 -mmmx -mno-3dnow
# -msse -msse2 -msse3 -mssse3 -msse4a -mcx16 -msahf -mmovbe -maes -msha
# -mpclmul -mpopcnt -mabm -mno-lwp -mfma -mno-fma4 -mno-xop -mbmi -mno-sgx
# -mbmi2 -mno-pconfig -mwbnoinvd -mno-tbm -mavx -mavx2 -msse4.2 -msse4.1
# -mlzcnt -mno-rtm -mno-hle -mrdrnd -mf16c -mfsgsbase -mrdseed -mprfchw
# -madx -mfxsr -mxsave -mxsaveopt -mno-avx512f -mno-avx512er -mno-avx512cd
# -mno-avx512pf -mno-prefetchwt1 -mclflushopt -mxsavec -mxsaves
# -mno-avx512dq -mno-avx512bw -mno-avx512vl -mno-avx512ifma -mno-avx512vbmi
# -mno-avx5124fmaps -mno-avx5124vnniw -mclwb -mmwaitx -mclzero -mno-pku
# -mrdpid -mno-gfni -mno-shstk -mno-avx512vbmi2 -mno-avx512vnni -mno-vaes
# -mno-vpclmulqdq -mno-avx512bitalg -mno-avx512vpopcntdq -mno-movdiri
# -mno-movdir64b -mno-waitpkg -mno-cldemote -mno-ptwrite -mno-avx512bf16
# -mno-enqcmd -mno-avx512vp2intersect --param=l1-cache-size=32
# --param=l1-cache-line-size=64 --param=l2-cache-size=512 -mtune=znver2
# -auxbase-strip binary.s -O3 -Wall -std=c++17 -fopt-info-vec-optimized
# -fverbose-asm
# options enabled:  -fPIC -fPIE -faggressive-loop-optimizations
# -falign-functions -falign-jumps -falign-labels -falign-loops
# -fallocation-dce -fasynchronous-unwind-tables -fauto-inc-dec
# -fbranch-count-reg -fcaller-saves -fcode-hoisting
# -fcombine-stack-adjustments -fcompare-elim -fcprop-registers
# -fcrossjumping -fcse-follow-jumps -fdefer-pop
# -fdelete-null-pointer-checks -fdevirtualize -fdevirtualize-speculatively
# -fdwarf2-cfi-asm -fearly-inlining -feliminate-unused-debug-symbols
# -feliminate-unused-debug-types -fexceptions -fexpensive-optimizations
# -ffinite-loops -fforward-propagate -ffp-int-builtin-inexact
# -ffunction-cse -fgcse -fgcse-after-reload -fgcse-lm -fgnu-unique
# -fguess-branch-probability -fhoist-adjacent-loads -fident -fif-conversion
# -fif-conversion2 -findirect-inlining -finline -finline-atomics
# -finline-functions -finline-functions-called-once
# -finline-small-functions -fipa-bit-cp -fipa-cp -fipa-cp-clone -fipa-icf
# -fipa-icf-functions -fipa-icf-variables -fipa-profile -fipa-pure-const
# -fipa-ra -fipa-reference -fipa-reference-addressable -fipa-sra
# -fipa-stack-alignment -fipa-vrp -fira-hoist-pressure
# -fira-share-save-slots -fira-share-spill-slots
# -fisolate-erroneous-paths-dereference -fivopts -fkeep-static-consts
# -fleading-underscore -flifetime-dse -floop-interchange
# -floop-unroll-and-jam -flra-remat -fmath-errno -fmerge-constants
# -fmerge-debug-strings -fmove-loop-invariants -fomit-frame-pointer
# -foptimize-sibling-calls -foptimize-strlen -fpartial-inlining
# -fpeel-loops -fpeephole -fpeephole2 -fplt -fpredictive-commoning
# -fprefetch-loop-arrays -free -freg-struct-return -freorder-blocks
# -freorder-blocks-and-partition -freorder-functions -frerun-cse-after-loop
# -fsched-critical-path-heuristic -fsched-dep-count-heuristic
# -fsched-group-heuristic -fsched-interblock -fsched-last-insn-heuristic
# -fsched-rank-heuristic -fsched-spec -fsched-spec-insn-heuristic
# -fsched-stalled-insns-dep -fschedule-fusion -fschedule-insns2
# -fsemantic-interposition -fshow-column -fshrink-wrap
# -fshrink-wrap-separate -fsigned-zeros -fsplit-ivs-in-unroller
# -fsplit-loops -fsplit-paths -fsplit-wide-types -fssa-backprop
# -fssa-phiopt -fstack-protector-strong -fstdarg-opt -fstore-merging
# -fstrict-aliasing -fstrict-volatile-bitfields -fsync-libcalls
# -fthread-jumps -ftoplevel-reorder -ftrapping-math -ftree-bit-ccp
# -ftree-builtin-call-dce -ftree-ccp -ftree-ch -ftree-coalesce-vars
# -ftree-copy-prop -ftree-cselim -ftree-dce -ftree-dominator-opts
# -ftree-dse -ftree-forwprop -ftree-fre -ftree-loop-distribute-patterns
# -ftree-loop-distribution -ftree-loop-if-convert -ftree-loop-im
# -ftree-loop-ivcanon -ftree-loop-optimize -ftree-loop-vectorize
# -ftree-parallelize-loops= -ftree-partial-pre -ftree-phiprop -ftree-pre
# -ftree-pta -ftree-reassoc -ftree-scev-cprop -ftree-sink
# -ftree-slp-vectorize -ftree-slsr -ftree-sra -ftree-switch-conversion
# -ftree-tail-merge -ftree-ter -ftree-vrp -funit-at-a-time -funswitch-loops
# -funwind-tables -fverbose-asm -fversion-loops-for-strides
# -fzero-initialized-in-bss -m128bit-long-double -m64 -m80387 -mabm -madx
# -maes -malign-stringops -mavx -mavx2 -mbmi -mbmi2 -mclflushopt -mclwb
# -mclzero -mcx16 -mf16c -mfancy-math-387 -mfma -mfp-ret-in-387 -mfsgsbase
# -mfxsr -mglibc -mieee-fp -mlong-double-80 -mlzcnt -mmmx -mmovbe -mmwaitx
# -mpclmul -mpopcnt -mprfchw -mpush-args -mrdpid -mrdrnd -mrdseed
# -mred-zone -msahf -msha -msse -msse2 -msse3 -msse4 -msse4.1 -msse4.2
# -msse4a -mssse3 -mstv -mtls-direct-seg-refs -mvzeroupper -mwbnoinvd
# -mxsave -mxsavec -mxsaveopt -mxsaves

	.text
	.section	.rodata.str1.1,"aMS",@progbits,1
.LC0:
	.string	"%d\n"
.LC2:
	.string	"%.4f s total time\n"
.LC6:
	.string	"%.2f ns per call\n"
	.section	.text.startup,"ax",@progbits
	.p2align 4
	.globl	main
	.type	main, @function
main:
.LFB10296:
	.cfi_startproc
	pushq	%r13	#
	.cfi_def_cfa_offset 16
	.cfi_offset 13, -16
	pushq	%r12	#
	.cfi_def_cfa_offset 24
	.cfi_offset 12, -24
	pushq	%rbp	#
	.cfi_def_cfa_offset 32
	.cfi_offset 6, -32
	pushq	%rbx	#
	.cfi_def_cfa_offset 40
	.cfi_offset 3, -40
	xorl	%ebx, %ebx	# ivtmp.46
	subq	$80040, %rsp	#,
	.cfi_def_cfa_offset 80080
# gcd.hh:6: int main(int argc, char* argv[]) {
	movq	%fs:40, %rax	# MEM[(<address-space-1> long unsigned int *)40B], tmp137
	movq	%rax, 80024(%rsp)	# tmp137, D.229036
	xorl	%eax, %eax	# tmp137
	leaq	16(%rsp), %r12	#, tmp129
	leaq	40016(%rsp), %r13	#, tmp130
.L2:
# gcd.hh:11:         a[i] = rand();
	call	rand@PLT	#
# gcd.hh:11:         a[i] = rand();
	movl	%eax, (%r12,%rbx)	# tmp131, MEM[symbol: a, index: ivtmp.46_72, offset: 0B]
# gcd.hh:12:         b[i] = rand();
	call	rand@PLT	#
# gcd.hh:12:         b[i] = rand();
	movl	%eax, 0(%r13,%rbx)	# tmp132, MEM[symbol: b, index: ivtmp.46_72, offset: 0B]
# gcd.hh:10:     for (int i = 0; i < n; i++) {
	addq	$4, %rbx	#, ivtmp.46
	cmpq	$40000, %rbx	#, ivtmp.46
	jne	.L2	#,
# gcd.hh:17:     clock_t start = clock();
	call	clock@PLT	#
# gcd.hh:15:     int checksum = 0;
	xorl	%ebp, %ebp	# checksum
# gcd.hh:17:     clock_t start = clock();
	movl	$500, %r9d	#, ivtmp_75
	movq	%rax, %rbx	# tmp133, start
.L6:
# gcd.hh:15:     int checksum = 0;
	xorl	%edi, %edi	# ivtmp.31
	.p2align 4
	.p2align 3
.L5:
# gcd.hh:21:             checksum += gcd(a[j], b[j]);
	movl	(%r12,%rdi), %ecx	# MEM[symbol: a, index: ivtmp.31_102, offset: 0B], _4
	movl	0(%r13,%rdi), %eax	# MEM[symbol: b, index: ivtmp.31_102, offset: 0B], _3
# binary.cc:5:     if (a == 0) return b;
	testl	%ecx, %ecx	# _4
	je	.L3	#,
# binary.cc:6:     if (b == 0) return a;
	testl	%eax, %eax	# _3
	je	.L8	#,
# binary.cc:8:     int az = __builtin_ctz(a);
	tzcntl	%ecx, %edx	# _4, _45
# binary.cc:9:     int bz = __builtin_ctz(b);
	tzcntl	%eax, %esi	# _3, bz
	cmpl	%esi, %edx	# bz, _45
	movl	%esi, %r8d	# bz, shift
# binary.cc:11:     a >>= az;
	sarx	%edx, %ecx, %ecx	# _45, _4, a
	cmovle	%edx, %r8d	# _45,, shift
	.p2align 4
	.p2align 3
.L4:
# binary.cc:14:         b >>= bz;
	sarx	%esi, %eax, %eax	# bz, _3, _53
# binary.cc:15:         int diff = b - a;
	movl	%eax, %edx	# _53, diff
	subl	%ecx, %edx	# a, diff
# binary.cc:16:         bz = __builtin_ctz(diff);
	tzcntl	%edx, %esi	# diff, bz
	cmpl	%eax, %ecx	# _53, a
	cmovg	%eax, %ecx	# a,, _53, a
# binary.cc:18:         b = abs(diff);
	movl	%edx, %eax	# diff, tmp116
	negl	%eax	# tmp116
	cmpl	%eax, %edx	# tmp116, diff
	cmovge	%edx, %eax	# diff,, _3
# binary.cc:13:     while (b != 0) {
	testl	%edx, %edx	# diff
	jne	.L4	#,
# binary.cc:21:     return a << shift;
	shlx	%r8d, %ecx, %eax	# shift, a, _3
.L3:
# gcd.hh:20:         for (int j = 0; j < n; j++)
	addq	$4, %rdi	#, ivtmp.31
# gcd.hh:21:             checksum += gcd(a[j], b[j]);
	addl	%eax, %ebp	# _3, checksum
# gcd.hh:20:         for (int j = 0; j < n; j++)
	cmpq	$40000, %rdi	#, ivtmp.31
	jne	.L5	#,
# gcd.hh:19:     for (int i = 0; i < k; i++)
	decl	%r9d	# ivtmp_75
	jne	.L6	#,
# gcd.hh:23:     float seconds = float(clock() - start) / CLOCKS_PER_SEC;
	call	clock@PLT	#
# gcd.hh:25:     printf("%d\n", checksum);
	movl	%ebp, %esi	# checksum,
	leaq	.LC0(%rip), %rdi	#,
# gcd.hh:23:     float seconds = float(clock() - start) / CLOCKS_PER_SEC;
	movq	%rax, %r12	# tmp134, _5
# gcd.hh:25:     printf("%d\n", checksum);
	xorl	%eax, %eax	#
	call	printf@PLT	#
# gcd.hh:23:     float seconds = float(clock() - start) / CLOCKS_PER_SEC;
	subq	%rbx, %r12	# start, tmp117
# gcd.hh:23:     float seconds = float(clock() - start) / CLOCKS_PER_SEC;
	vxorps	%xmm0, %xmm0, %xmm0	# tmp135
# gcd.hh:26:     printf("%.4f s total time\n", seconds);
	leaq	.LC2(%rip), %rdi	#,
# gcd.hh:23:     float seconds = float(clock() - start) / CLOCKS_PER_SEC;
	vcvtsi2ssq	%r12, %xmm0, %xmm0	# tmp117, tmp135, tmp136
# gcd.hh:23:     float seconds = float(clock() - start) / CLOCKS_PER_SEC;
	vdivss	.LC1(%rip), %xmm0, %xmm0	#, tmp118, seconds
# gcd.hh:26:     printf("%.4f s total time\n", seconds);
	movl	$1, %eax	#,
	vcvtss2sd	%xmm0, %xmm0, %xmm0	# seconds, _8
	vmovsd	%xmm0, 8(%rsp)	# _8, %sfp
	call	printf@PLT	#
# gcd.hh:27:     printf("%.2f ns per call\n", 1e9 * seconds / n / k);
	vmovsd	8(%rsp), %xmm0	# %sfp, _8
# gcd.hh:27:     printf("%.2f ns per call\n", 1e9 * seconds / n / k);
	leaq	.LC6(%rip), %rdi	#,
# gcd.hh:27:     printf("%.2f ns per call\n", 1e9 * seconds / n / k);
	vmulsd	.LC3(%rip), %xmm0, %xmm0	#, _8, tmp121
# gcd.hh:27:     printf("%.2f ns per call\n", 1e9 * seconds / n / k);
	movl	$1, %eax	#,
# gcd.hh:27:     printf("%.2f ns per call\n", 1e9 * seconds / n / k);
	vdivsd	.LC4(%rip), %xmm0, %xmm0	#, tmp121, tmp123
# gcd.hh:27:     printf("%.2f ns per call\n", 1e9 * seconds / n / k);
	vdivsd	.LC5(%rip), %xmm0, %xmm0	#, tmp123, tmp125
	call	printf@PLT	#
# gcd.hh:30: }
	movq	80024(%rsp), %rax	# D.229036, tmp138
	subq	%fs:40, %rax	# MEM[(<address-space-1> long unsigned int *)40B], tmp138
	jne	.L18	#,
	addq	$80040, %rsp	#,
	.cfi_remember_state
	.cfi_def_cfa_offset 40
	xorl	%eax, %eax	#
	popq	%rbx	#
	.cfi_def_cfa_offset 32
	popq	%rbp	#
	.cfi_def_cfa_offset 24
	popq	%r12	#
	.cfi_def_cfa_offset 16
	popq	%r13	#
	.cfi_def_cfa_offset 8
	ret	
	.p2align 4
	.p2align 3
.L8:
	.cfi_restore_state
	movl	%ecx, %eax	# _4, _3
	jmp	.L3	#
.L18:
	call	__stack_chk_fail@PLT	#
	.cfi_endproc
.LFE10296:
	.size	main, .-main
	.text
	.p2align 4
	.globl	_Z3gcdii
	.type	_Z3gcdii, @function
_Z3gcdii:
.LFB10297:
	.cfi_startproc
	movl	%esi, %eax	# b, <retval>
# binary.cc:5:     if (a == 0) return b;
	testl	%edi, %edi	# a
	je	.L19	#,
	movl	%edi, %eax	# a, <retval>
# binary.cc:6:     if (b == 0) return a;
	testl	%esi, %esi	# b
	je	.L19	#,
# binary.cc:8:     int az = __builtin_ctz(a);
	tzcntl	%edi, %eax	# a, _4
# binary.cc:9:     int bz = __builtin_ctz(b);
	tzcntl	%esi, %edx	# b, bz
	cmpl	%edx, %eax	# bz, _4
	movl	%edx, %ecx	# bz, shift
# binary.cc:11:     a >>= az;
	sarx	%eax, %edi, %edi	# _4, a, a
	cmovle	%eax, %ecx	# _4,, shift
	.p2align 4
	.p2align 3
.L21:
# binary.cc:14:         b >>= bz;
	sarx	%edx, %esi, %esi	# bz, b, _10
# binary.cc:15:         int diff = b - a;
	movl	%esi, %eax	# _10, diff
	subl	%edi, %eax	# a, diff
# binary.cc:16:         bz = __builtin_ctz(diff);
	tzcntl	%eax, %edx	# diff, bz
	cmpl	%esi, %edi	# _10, a
	cmovg	%esi, %edi	# a,, _10, a
# binary.cc:18:         b = abs(diff);
	movl	%eax, %esi	# diff, tmp94
	negl	%esi	# tmp94
	cmpl	%esi, %eax	# tmp94, diff
	cmovge	%eax, %esi	# diff,, b
# binary.cc:13:     while (b != 0) {
	testl	%eax, %eax	# diff
	jne	.L21	#,
# binary.cc:21:     return a << shift;
	shlx	%ecx, %edi, %eax	# shift, a, <retval>
.L19:
# binary.cc:22: }
	ret	
	.cfi_endproc
.LFE10297:
	.size	_Z3gcdii, .-_Z3gcdii
	.section	.text.startup
	.p2align 4
	.type	_GLOBAL__sub_I_main, @function
_GLOBAL__sub_I_main:
.LFB11930:
	.cfi_startproc
	subq	$8, %rsp	#,
	.cfi_def_cfa_offset 16
# /usr/include/c++/10.2.0/iostream:74:   static ios_base::Init __ioinit;
	leaq	_ZStL8__ioinit(%rip), %rdi	#,
	call	_ZNSt8ios_base4InitC1Ev@PLT	#
	movq	_ZNSt8ios_base4InitD1Ev@GOTPCREL(%rip), %rdi	#,
	leaq	__dso_handle(%rip), %rdx	#,
	leaq	_ZStL8__ioinit(%rip), %rsi	#,
# binary.cc:22: }
	addq	$8, %rsp	#,
	.cfi_def_cfa_offset 8
# /usr/include/c++/10.2.0/iostream:74:   static ios_base::Init __ioinit;
	jmp	__cxa_atexit@PLT	#
	.cfi_endproc
.LFE11930:
	.size	_GLOBAL__sub_I_main, .-_GLOBAL__sub_I_main
	.section	.init_array,"aw"
	.align 8
	.quad	_GLOBAL__sub_I_main
	.local	_ZStL8__ioinit
	.comm	_ZStL8__ioinit,1,1
	.section	.rodata.cst4,"aM",@progbits,4
	.align 4
.LC1:
	.long	1232348160
	.section	.rodata.cst8,"aM",@progbits,8
	.align 8
.LC3:
	.long	0
	.long	1104006501
	.align 8
.LC4:
	.long	0
	.long	1086556160
	.align 8
.LC5:
	.long	0
	.long	1082081280
	.hidden	__dso_handle
	.ident	"GCC: (GNU) 10.2.0"
	.section	.note.GNU-stack,"",@progbits
